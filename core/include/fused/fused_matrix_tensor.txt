// #include <array>
// #include <iostream>
// #include "expr.h"

// template<typename T, std::size_t N>
// struct Vector : public Expr<Vector<T, N>> {
//     using value_type = T;
//     std::array<T, N> data;

//     Vector() = default;

//     // Constructor from initializer list
//     Vector(std::initializer_list<T> init) {
//         std::copy(init.begin(), init.end(), data.begin());
//     }

//     T operator[](index_t i) const { return data[i]; }
//     T& operator[](index_t i) { return data[i]; }

//     index_t size() const { return N; }

//     // Assignment from expression
//     template<typename ExprType>
//     Vector& operator=(const Expr<ExprType>& expr) {
//         std::cout << "Vector assignment operator called" << std::endl;
//         const auto& e = expr.derived();
//         for (index_t i = 0; i < N; ++i) {
//             data[i] = e[i];
//         }
//         return *this;
//     }

//     Vector& operator=(const Vector& other) {
//         std::cout << "Vector copy assignment\n";
//         std::copy(other.data.begin(), other.data.end(), data.begin());
//     return *this;
// }
//     Vector(const Vector &other)
//     {
//         std::cout << "Copy constructor called" << std::endl;

//         // std::copy(other._data, other._data + (Rows * Cols), _data);
//     }

//     void print() const {
//         for (index_t i = 0; i < N; ++i) {
//             std::cout << data[i] << " ";
//         }
//         std::cout << std::endl;
//     }

// };

// ===============================
// Fixed-Size Matrix Class
// ===============================
template <typename T, my_size_t Rows, my_size_t Cols, my_size_t... Dims>
class FusedMatrix : public BaseExpr<FusedMatrix<T, Rows, Cols, Dims...>, T>
{
    T _data[Rows * Cols];

public:
    FusedMatrix() = default;

    T operator()(my_size_t i, my_size_t j) const
    {
        return _data[i * Cols + j];
    }

    // T& operator()(my_size_t i, my_size_t j) {
    //     return _data[i * Cols + j];
    // }

    T operator()(my_size_t idx) const
    {
        std::cout << "Accessing index " << idx << std::endl;
        return _data[idx];
    }
    const double *debugDataPtr() const { return _data; }

    // T& operator()(my_size_t idx) { return _data[idx]; }

    // my_size_t rows() const { return Rows; }
    // my_size_t cols() const { return Cols; }

    // template<typename Expr>
    // FusedMatrix& operator=(const BaseExpr<Expr, T>& expr) {
    //     const auto& e = expr.derived();
    //     for (my_size_t i = 0; i < Rows; ++i)
    //         for (my_size_t j = 0; j < Cols; ++j)
    //             (*this)(i, j) = e(i, j);
    //     return *this;
    // }

    template <typename Expr>
    FusedMatrix &operator=(const BaseExpr<Expr, T> &expr)
    {
        std::cout << "Assignment operator called" << std::endl;
        const auto &e = expr.derived();
        for (my_size_t idx = 0; idx < Rows * Cols; ++idx)
            _data[idx] = e(idx); // flat access
        return *this;
    }

    FusedMatrix &operator=(const FusedMatrix &other)
    {
        std::cout << "FusedMatrix copy assignment\n";
        std::copy(other._data, other._data + (Rows * Cols), _data);
        return *this;
    }

    FusedMatrix(const FusedMatrix &other)
    {
        std::cout << "Copy constructor called" << std::endl;

        // std::copy(other._data, other._data + (Rows * Cols), _data);
    }

    // FusedMatrix(const FusedMatrix&) = delete;
    // FusedMatrix& operator=(const FusedMatrix&) = delete;

    FusedMatrix &setHomogen(T _val)
    {
        std::fill_n(_data, Rows * Cols, _val);
        return *this;
    }

    // 2D print function
    void print2D() const
    {
        // account for the trnaspose order as well
        for (my_size_t i = 0; i < Rows; ++i)
        {
            for (my_size_t j = 0; j < Cols; ++j)
            {
                // std::cout << "(" << i << "," << j << ") ";
                std::cout << (*this)(i, j) << " ";
            }
            std::cout << std::endl;
        }
    }
};

// ===============================
// Matrix Multiplication (Dot Product)
// ===============================
// template<my_size_t M, my_size_t N, my_size_t K>
// Matrix<M, K> matmul(const Matrix<M, N>& A, const Matrix<N, K>& B) {
//     Matrix<M, K> result;
//     for (my_size_t i = 0; i < M; ++i) {
//         for (my_size_t j = 0; j < K; ++j) {
//             float sum = 0.0f;
//             for (my_size_t k = 0; k < N; ++k)
//                 sum += A(i, k) * B(k, j);
//             result(i, j) = sum;
//         }
//     }
//     return result;
// }

// ===============================
// Example Usage (Uncomment to Use)
// ===============================
/*
int main() {
    Matrix<2, 2> A, B, D, C;

    A(0,0)=1; A(0,1)=2; A(1,0)=3; A(1,1)=4;
    B(0,0)=5; B(0,1)=6; B(1,0)=7; B(1,1)=8;
    D(0,0)=1; D(0,1)=1; D(1,0)=1; D(1,1)=1;

    C = (A + B) * (D - A) + 2.0f;

    auto E = matmul(A, B);
}
*/
